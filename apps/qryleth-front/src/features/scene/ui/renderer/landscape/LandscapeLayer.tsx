import React, { useMemo, useState } from 'react'
import * as THREE from 'three'
import type { SceneLayer } from '@/entities/scene/types.ts'
import { useSceneStore } from '@/features/scene/model/sceneStore.ts'
import { createPerlinGeometry } from '@/features/scene/lib/geometry/perlinGeometry.ts'
import { DEFAULT_LANDSCAPE_COLOR } from '@/features/scene/constants.ts'
import { GfxLayerType, GfxLayerShape } from '@/entities/layer'
import type { GfxTerrainConfig } from '@/entities/terrain'
import { createGfxHeightSampler, buildGfxTerrainGeometry } from '@/features/scene/lib/terrain/GfxHeightSampler.ts'

export interface LandscapeLayerProps {
  layer: SceneLayer
}

/**
 * –°–æ–∑–¥–∞—Ç—å terrain –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∏–∑ legacy –¥–∞–Ω–Ω—ã—Ö —Å–ª–æ—è –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
 * @param layer - —Å–ª–æ–π —Å—Ü–µ–Ω—ã —Å legacy –¥–∞–Ω–Ω—ã–º–∏
 * @returns –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Ç–µ—Ä—Ä–µ–π–Ω–∞ –¥–ª—è GfxHeightSampler
 */
const createLegacyTerrainConfig = (layer: SceneLayer): GfxTerrainConfig | null => {
  if (layer.shape === GfxLayerShape.Terrain && layer.noiseData) {
    return {
      worldWidth: layer.width || 1,
      worldHeight: layer.height || 1,
      edgeFade: 0.15, // —Ç–∞–∫–æ–µ –∂–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–∞–∫ –≤ createPerlinGeometry
      source: {
        kind: 'legacy',
        data: new Float32Array(layer.noiseData),
        width: layer.width && layer.width > 200 ? 200 : layer.width || 1,
        height: layer.height && layer.height > 200 ? 200 : layer.height || 1
      }
    }
  }
  return null
}

/**
 * –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –ª–∞–Ω–¥—à–∞—Ñ—Ç–Ω–æ–≥–æ —Å–ª–æ—è.
 * –ü—Ä–∏–Ω–∏–º–∞–µ—Ç —Å–ª–æ–π —Å—Ü–µ–Ω—ã –∏ —Å–æ–∑–¥–∞—ë—Ç —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –≥–µ–æ–º–µ—Ç—Ä–∏—é –∏ –º–∞—Ç–µ—Ä–∏–∞–ª.
 * –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –Ω–æ–≤—É—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É GfxHeightSampler –∏ legacy —Ä–µ–∂–∏–º –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏.
 * –¶–≤–µ—Ç –º–∞—Ç–µ—Ä–∏–∞–ª–∞ –±–µ—Ä—ë—Ç—Å—è –∏–∑ —Å–≤–æ–π—Å—Ç–≤–∞ `color` —Å–ª–æ—è, –≤–Ω–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –µ–≥–æ —Ñ–æ—Ä–º—ã.
 */
export const LandscapeLayer: React.FC<LandscapeLayerProps> = ({ layer }) => {
  const updateLayer = useSceneStore(state => state.updateLayer)

  // –°–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≥–µ–æ–º–µ—Ç—Ä–∏–∏ –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ heightmap
  const [heightmapLoaded, setHeightmapLoaded] = useState(false)

  const geometry = useMemo(() => {
    if (layer.shape === GfxLayerShape.Terrain) {
      // –ù–æ–≤–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞: –∏—Å–ø–æ–ª—å–∑—É–µ–º GfxHeightSampler –µ—Å–ª–∏ –µ—Å—Ç—å terrain –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
      if (layer.terrain) {
        console.log('üóª LandscapeLayer: Using terrain config for layer', layer.id, layer.terrain)
        const sampler = createGfxHeightSampler(layer.terrain)
        
        // –î–ª—è heightmap –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤: –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ —Å–æ–±—ã—Ç–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö
        if (layer.terrain.source.kind === 'heightmap') {
          // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ—Ç–æ–¥ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π)
          sampler.onHeightmapLoaded?.(() => {
            console.log('üóª Heightmap data loaded, triggering geometry rebuild')
            // –õ–æ–∫–∞–ª—å–Ω–æ —Ç—Ä–∏–≥–≥–µ—Ä–∏–º –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏–µ –º–µ—à–∞/–≥–µ–æ–º–µ—Ç—Ä–∏–∏
            setHeightmapLoaded(prev => !prev)
            // –ò –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º —Å–ª–æ–π –≤ —Å—Ç–æ—Ä–µ —Ç–µ–º–∏ –∂–µ –¥–∞–Ω–Ω—ã–º–∏, —á—Ç–æ–±—ã
            // –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ —Ä–∞–∑—Ä—É—à–∏—Ç—å –º–µ–º–æ–∏–∑–∞—Ü–∏—é –ø–æ —Å—Å—ã–ª–∫–µ terrain –∏ –ø–µ—Ä–µ—Å–æ–±—Ä–∞—Ç—å –ø–æ—Ç–æ–º–∫–æ–≤
            if (layer.terrain) {
              updateLayer(layer.id, { terrain: { ...layer.terrain } })
            }
          })
        }
        
        const geometry = buildGfxTerrainGeometry(layer.terrain, sampler)
        console.log('üóª LandscapeLayer: Generated geometry with vertices:', geometry.attributes.position.count)
        return geometry
      }
      
      // Legacy —Ä–µ–∂–∏–º: —Å–æ–∑–¥–∞–µ–º terrain –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∏–∑ noiseData
      const legacyConfig = createLegacyTerrainConfig(layer)
      if (legacyConfig) {
        const sampler = createGfxHeightSampler(legacyConfig)
        return buildGfxTerrainGeometry(legacyConfig, sampler)
      }
      
      // –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π terrain –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –¥–ª—è —Å–ª–æ–µ–≤ –±–µ–∑ –¥–∞–Ω–Ω—ã—Ö
      const newTerrainConfig: GfxTerrainConfig = {
        worldWidth: layer.width || 1,
        worldHeight: layer.height || 1,
        edgeFade: 0.15,
        source: {
          kind: 'perlin',
          params: {
            seed: 1234,
            octaveCount: 4,
            amplitude: 0.1,
            persistence: 0.5,
            width: (layer.width && layer.width > 200) ? 200 : (layer.width || 1),
            height: (layer.height && layer.height > 200) ? 200 : (layer.height || 1)
          }
        }
      }
      
      // –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤—É—é terrain –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –≤ store
      updateLayer(layer.id, { terrain: newTerrainConfig })
      
      // –°–æ–∑–¥–∞–µ–º –≥–µ–æ–º–µ—Ç—Ä–∏—é —Å –Ω–æ–≤–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–µ–π
      const sampler = createGfxHeightSampler(newTerrainConfig)
      return buildGfxTerrainGeometry(newTerrainConfig, sampler)
    } else {
      return new THREE.PlaneGeometry(layer.width || 1, layer.height || 1)
    }
  }, [layer.width, layer.height, layer.shape, layer.noiseData, layer.terrain, layer.id, updateLayer, heightmapLoaded])

  const materialColor = useMemo(() => {
    if (layer.color) {
      return new THREE.Color(layer.color)
    }
    if (layer.shape === GfxLayerShape.Terrain) {
      return new THREE.Color('#4a7c59')
    } else {
      return new THREE.Color(DEFAULT_LANDSCAPE_COLOR)
    }
  }, [layer.shape, layer.color])

  const rotation = useMemo(() => {
    if (layer.shape === GfxLayerShape.Terrain) {
      return [0, 0, 0] // Terrain geometries are already horizontal (rotated in buildGfxTerrainGeometry)
    } else {
      return [-Math.PI / 2, 0, 0] // Rotate plane to be horizontal
    }
  }, [layer.shape])

  return (
    <mesh
      // –ö–ª—é—á –∑–∞–≤–∏—Å–∏—Ç –æ—Ç heightmapLoaded —á—Ç–æ–±—ã –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –ø–µ—Ä–µ—Å–æ–∑–¥–∞—Ç—å Mesh –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏
      key={`${layer.id}-${heightmapLoaded ? 'hm1' : 'hm0'}`}
      geometry={geometry}
      visible={layer.visible}
      rotation={rotation}
      position={[0, 0.1, 0]} // Slightly above grid for better visibility
      receiveShadow
      userData={{
        generated: true,
        layerId: layer.id,
        layerType: GfxLayerType.Landscape
      }}
    >
      <meshLambertMaterial
        color={materialColor}
        side={THREE.DoubleSide}
        wireframe={false}
        transparent={false}
        opacity={1.0}
      />
    </mesh>
  )
}
