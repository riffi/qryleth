/**
 * Параметры процедурной генерации дерева.
 * На основе этих значений генератор строит набор примитивов ствола/ветвей/листвы
 * и возвращает их для добавления в редактируемый объект.
 */
export interface TreeGeneratorParams {
  /** Сид случайности для детерминированной генерации */
  seed: number
  /** Общая высота ствола (в единицах сцены) */
  trunkHeight: number
  /** Радиус ствола у основания */
  trunkRadius: number
  /** Количество сегментов ствола (вертикальная детализация) */
  trunkSegments: number
  /**
   * Сила скоса сегментов ствола (0..1).
   * 0 — сегменты ориентированы строго по оси ствола (как раньше);
   * 1 — каждый сегмент сильно наклонён в случайном азимуте, при этом
   *     соседние сегменты стыкуются без зазоров (используется перекрытие и «воротник»).
   * Значение линейно масштабирует максимально возможный угол наклона сегмента
   * (по умолчанию до ~35° при 1.0).
   */
  trunkShearStrength?: number
  /**
   * Коэффициент сужения ствола к верху (0..1).
   * 0 — без сужения; 1 — радиус к верху стремится к нулю.
   * Рекомендуемые значения 0.2..0.6. По умолчанию 0.4.
   */
  trunkTaperFactor?: number
  /** Количество уровней ветвления (0 — без ветвей) */
  branchLevels: number
  /** Количество ветвей на сегмент ствола (усреднённо) */
  branchesPerSegment: number
  /**
   * Разброс количества дочерних веток на узел (0..1).
   * 0 — фиксированное округлённое значение; 1 — вариация около ±100% от среднего.
   */
  branchCountJitter?: number
  /**
   * Привязка ветвей к верхней части дерева (0..1).
   * 0 — ветви формируются равномерно вдоль высоты,
   * 1 — ветви концентрируются у верхних сегментов (внизу почти нет ветвей).
   */
  branchTopBias?: number

  /**
   * Стремление ветвей «смотреть вверх» (0..1).
   * 0 — без предпочтения (как сейчас), 1 — направления с отрицательной Y‑составляющей
   * сильно штрафуются при выборе кандидата (ветка ориентируется вверх).
   */
  branchUpBias?: number
  /** Длина ветви базовая (умножается на коэффициенты по уровням) */
  branchLength: number
  /**
   * Разброс длины ветви (0..1). Если не задан — используется значение `randomness`.
   * 0 — без разброса; 1 — примерно ±30% от базовой длины.
   */
  branchLengthJitter?: number
  /** Радиус ветви на первом уровне (тоньше на следующих уровнях) */
  branchRadius: number
  /**
   * Коэффициент уменьшения радиуса веток на каждом следующем уровне (0..1).
   * Пример: 0.7 означает, что радиус веток уровня N+1 равен 0.7 × радиуса уровня N.
   * По умолчанию 0.7.
   */
  branchRadiusFalloff?: number
  /** Угол наклона ветви от вертикали, в градусах */
  branchAngleDeg: number
  /**
   * Переопределение угла для уровня 1 (если задано). Если не задан — используется branchAngleDeg.
   */
  branchAngleDegFirst?: number
  /**
   * Переопределение угла для уровней ≥2 (если задано). Если не задан — используется branchAngleDeg.
   */
  branchAngleDegNext?: number
  /** Доля случайного разброса параметров (0..1) */
  randomness: number
  /** Количество листьев на конце каждой ветви (на верхнем уровне) */
  leavesPerBranch: number
  /** Размер (радиус) листа, если рендерим лист как сферу */
  leafSize: number
  /**
   * Сужение ветки к кончику (0..1). 0 — без сужения; 1 — стремится к нулю у кончика.
   * Используется в функции taper трубки ветки. По умолчанию 0.35.
   */
  branchTipTaper?: number

  /**
   * Базовый уровень изгиба ветвей (0..1).
   * 0 — почти прямые ветки, 1 — заметный прогиб и плавный изгиб.
   */
  branchBendBase?: number
  /**
   * Уровень разброса изгиба ветвей (0..1): усиливает случайные вариации
   * прогиба и бокового отклонения контрольных точек кривой.
   */
  branchBendJitter?: number

  /**
   * Размер «воротника» у основания веток (0..1):
   * увеличивает выраженность плавного утолщения на стыке с родителем,
   * при этом сама круглая грань остаётся утопленной и не видна.
   */
  branchCollarSize?: number
  /** Длина воротника (доля длины ветки от основания, 0..0.6). */
  branchCollarFrac?: number
  /**
   * Тип листвы: оставлен только 'texture'. Ранее поддерживались 'billboard', 'sphere' и 'coniferCross'.
   * Поле сохраняется в схеме для явной фиксации варианта и будущей расширяемости.
   */
  leafShape?: 'texture'
  /**
   * Наклон листа к поверхности ветви (в градусах, 0..90).
   * 0° — лист параллелен поверхности ветки, «смотрит» наружу (нормаль = радиальная наружу).
   * 90° — лист перпендикулярен ветке (нормаль совпадает с осью ветви).
   * Применяется для текстурной листвы.
   */
  leafTiltDeg?: number
  /**
   * Глобальное стремление листвы: направление дополнительного поворота.
   * 'up' — стремление вверх (листья «поднимаются» к глобальной оси Y),
   * 'down' — стремление вниз (листья «опускаются»), 'none' — не используется.
   * Учитывается как добавка к углу наклона (leafTiltDeg), с автоматическим учётом направления
   * текущей ветви относительно глобальной оси Y.
   */
  leafGlobalTiltMode?: 'up' | 'down' | 'none'
  /**
   * Уровень глобального стремления листвы (0..1).
   * 0 — эффект отключён. 1 — нормаль листа стремится строго к мировой оси Y (для 'up') или к -Y (для 'down').
   * Реализуется плавным поворотом текущей нормали листа к целевому направлению пропорционально уровню.
   */
  leafGlobalTiltLevel?: number
  /**
   * Идентификатор набора текстур листвы из реестра (leafTextureRegistry).
   * Например: 'leafset019-1k-jpg' или 'leafset024-1k-jpg'.
   * Применяется для выбора карт и atlas.json.
   */
  leafTextureSetId?: string
  /**
   * Идентификатор набора текстур коры из реестра (woodTextureRegistry).
   * Применяется для ствола и ветвей как единая текстура объекта.
   * Пример: 'bark014-1k-jpg'.
   */
  barkTextureSetId?: string
  /**
   * Повторение UV для коры по осям U/V. Значения >1 увеличивают количество «плиток» текстуры
   * на стволе/ветвях (масштабируют текстуру). По умолчанию 1×1.
   */
  barkUvRepeatU?: number
  /** См. barkUvRepeatU — повторение по оси V. */
  barkUvRepeatV?: number
  /**
   * Единая плотность текстуры коры (повторов на метр) для ствола и веток.
   * Используется для пересчёта UV так, чтобы масштаб коры был визуально единым.
   * По умолчанию 1 повтор/м.
   */
  barkTexDensityPerMeter?: number
  /**
   * Имя спрайта (подпрямоугольника) из atlas.json выбранного набора.
   * Если не задано — берётся первый элемент атласа.
   */
  leafTextureSpriteName?: string
  /**
   * Использовать все спрайты атласа (равномерно в случайном порядке).
   * Если true и задан массив leafSpriteNames,
   * то при генерации каждому листу выбирается имя спрайта из списка детерминированным rng.
   */
  useAllLeafSprites?: boolean
  /**
   * Список имён спрайтов, доступных для выбора при useAllLeafSprites.
   * Если не задан — поведение как при useAllLeafSprites=false (используется leafTextureSpriteName).
   */
  leafSpriteNames?: string[]
  /**
   * Фактор покраски текстурированных листьев (0..1).
   * 0 — без изменений альбедо текстуры; 1 — максимально приводим оттенок
   * (Hue) и насыщенность (Saturation) пикселей цветовой карты листьев к цвету
   * материала листвы. Яркость (Value) сохраняется, чтобы сохранить объём и
   * детали исходной текстуры. Значения между 0 и 1 выполняют плавную интерполяцию
   * в пространстве HSV по кратчайшей дуге тона.
   * Применяется только для текстурной листвы.
   */
  leafTexturePaintFactor?: number
  /**
   * Разброс применения фактора покраски по листьям (0..1).
   * 0 — у всех листьев одинаковый коэффициент покраски (равен leafTexturePaintFactor).
   * 1 — максимальный разброс: для каждого листа коэффициент выбирается детерминированно
   *     из диапазона [0 .. leafTexturePaintFactor]. Промежуточные значения линейно
   *     сужают нижнюю границу диапазона: при 0.5 — [0.5*leafTexturePaintFactor .. leafTexturePaintFactor].
   * Используется только для текстурной листвы.
   */
  leafTexturePaintJitter?: number
  /**
   * Схема размещения листвы: только на концах ветвей ('end') или вдоль ветви ('along').
   */
  leafPlacement?: 'end' | 'along'
  /**
   * Плотность листвы вдоль ветви (кластеров на метр). Используется при leafPlacement='along'.
   */
  leavesPerMeter?: number
  /**
   * Разброс наклона ветви относительно вертикали (0..1).
   * Применяется к параметру `branchAngleDeg`: при 0 — без разброса (точно
   * `branchAngleDeg`), при 1 — максимальный джиттер наклона (порядка ±50%
   * от `branchAngleDeg`). На азимут не влияет: азимут выбирается случайно
   * равномерно в диапазоне [0..2π].
   */
  angleSpread?: number

  /**
   * Коэффициент заглубления ответвлений в родительскую ветку/ствол (0..1).
   * Глубина заглубления рассчитывается как min(parentRadius, branchRadius) * embedFactor
   * и используется, чтобы скрыть торцевую круглую грань цилиндра ветки внутри
   * родительского цилиндра. Значение по умолчанию: 0.6.
   */
  embedFactor?: number

  /**
   * Количество уровней разветвления самого ствола (0 — без разветвления ствола).
   * Каждый уровень создаёт ответвления-стволы меньшего радиуса с небольшим наклоном.
   * По умолчанию 0.
   */
  trunkBranchLevels?: number
  /**
   * Сколько стволов образуется на каждом уровне разветвления. По умолчанию 2.
   */
  trunkBranchesPerLevel?: number
  /**
   * Угол наклона ответвлений ствола от вертикали (в градусах). По умолчанию 20°.
   */
  trunkBranchAngleDeg?: number
  /**
   * Во сколько раз короче высота дочерних стволов относительно родителя (0..1). По умолчанию 0.7.
   */
  trunkBranchChildHeightFactor?: number

  /**
   * Стремление начала дочерней ветки к концу родительской (0..1).
   * 0 — точки крепления равномерно по длине родителя; 1 — почти всегда у самого конца.
   */
  branchChildTipBias?: number
  /**
   * Минимальная доля длины родителя от базы, где запрещено крепление дочерних веток (0..0.5).
   * Помогает избежать конфликта с воротником у основания родительской ветки.
   */
  branchChildAvoidBaseFrac?: number

  /**
   * Отсечка появления веток по высоте (в абсолютных единицах Y).
   * Ветки, чьи точки крепления находятся ниже этой высоты, не создаются вовсе.
   * Диапазон слайдера в UI: [0 .. trunkHeight]. По умолчанию 0 (без отсечки).
   */
  branchHeightCutoff?: number

}

/**
 * Результат генерации дерева: примитивы и базовые материалы (без UUID).
 */
export interface TreeGeneratorResult {
  primitives: import('@/entities/primitive').GfxPrimitive[]
  materials: import('@/entities/material').CreateGfxMaterial[]
}
