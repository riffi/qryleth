# Обсуждение: Создание агентской задачи для рефакторинга ChatInterface для соответствия FSD

## Метаданные
- **Дата создания**: 2025-08-04
- **Статус**: Активное
- **Количество участников**: 1
- **Приоритет**: Средний
- **Временные рамки**: Не критично

## Постановка задачи
В данный момент ChatInterface, который является частью фичи sceneEditor, находится в папке widgets.
Необходимо:
1) Перенести его в соответствующую фичу
2) Так как аналогичный ChatInterface нужен и для objectEditor, вынести общую функциональность в shared/entities
3) Создать специализированные ChatInterface для каждой фичи
4) Продумать, куда именно в objectEditor засунуть блок с будущим чатом, сейчас левая панель уже занята

КРИТЕРИИ УСПЕХА:
- Функциональность чатов, не привязанная к конкретным фичам, вынесена в общие файлы
- ChatInterface, специфичный для фичи sceneEditor находится внутри своей фичи
- ChatInterface, специфичный для фичи objectEditor находится внутри своей фичи и создана его минимальная функциональность

## Мысли агента 1
Анализируя задачу рефакторинга ChatInterface для соответствия архитектуре FSD, я вижу следующие ключевые аспекты:

### Архитектурный анализ
- **Текущее состояние**: ChatInterface находится в widgets, что не соответствует FSD
- **Целевое состояние**: Разделение на общую функциональность (shared) и специфичные для фич реализации

### Предлагаемый подход
1. **Анализ существующего кода** ChatInterface для выделения общей и специфичной функциональности
2. **Создание базовой сущности** в `shared/entities/chat` с общими интерфейсами и логикой
3. **Рефакторинг для sceneEditor** - перенос специфичной логики в `features/sceneEditor/ui/ChatInterface`
4. **Создание для objectEditor** - новый компонент в `features/objectEditor/ui/ChatInterface`
5. **Решение UI-задачи** для objectEditor - анализ интерфейса и предложение места размещения

### Техническая оценка
- **Сложность реализации**: 6/10 (средне-высокая из-за необходимости анализа зависимостей)
- **Риски и ограничения**: 
  - Возможные breaking changes при рефакторинге
  - Необходимость обновления импортов во всех зависимых компонентах
  - Риск нарушения существующей функциональности sceneEditor
- **Зависимости**: 
  - Компоненты, использующие текущий ChatInterface
  - Система стейт-менеджмента чатов
  - UI-компоненты для objectEditor
- **Альтернативы**: 
  - Полное дублирование компонента (не рекомендуется)
  - Использование композиции вместо наследования
  - Создание хука/сервиса для общей логики

### Следующие шаги
1. Изучить существующий код ChatInterface
2. Проанализировать интерфейс objectEditor для определения места размещения
3. Спланировать миграцию с минимальными breaking changes

## Мысли агента 2 (Техническая детализация)

### Анализ существующего кода ChatInterface
После изучения текущего кода `src/widgets/ChatInterface.tsx` (480 строк), выявлены следующие ключевые компоненты:

**Общая функциональность (для shared/entities):**
- Интерфейсы: `ChatMessage`, базовые типы сообщений
- UI компоненты: базовая структура чата, сообщения, интерфейс ввода
- Системы автоскролла и таймстампов
- Базовая логика отправки/получения сообщений

**Специфичная для sceneEditor функциональность:**
- Интеграция с `addNewObjectTool` и `createAddNewObjectTool` (строки 9, 36-43, 110-120)
- Callbacks для успешного добавления объектов в сцену (строки 67-93)
- Debug-панель с JSON выводом для создания объектов (строки 421-476)
- Специфичные промпты ("Попросите агента добавить объект в сцену...")

### Архитектурный план реализации

**1. Создание базовых сущностей в shared:**
```
src/shared/entities/chat/
├── types/
│   ├── ChatMessage.ts
│   └── ChatConfig.ts
├── ui/
│   ├── ChatMessageItem/
│   ├── ChatInput/
│   └── ChatContainer/
└── lib/
    ├── hooks/
    │   ├── useChat.ts
    │   └── useChatScroll.ts
    └── utils/
        └── chatUtils.ts
```

**2. Структура для sceneEditor:**
```
src/features/scene/ui/ChatInterface/
├── SceneChatInterface.tsx
├── components/
│   ├── SceneDebugPanel/
│   └── SceneToolCallbacks/
└── hooks/
    └── useSceneChat.ts
```

**3. Структура для objectEditor (обновлено):**
```
src/features/object-editor/ui/
├── ChatInterface/
│   ├── ObjectChatInterface.tsx
│   ├── components/
│   │   └── ObjectToolCallbacks/
│   └── hooks/
│       └── useObjectChat.ts
├── PanelToggleButtons/
│   ├── PanelToggleButtons.tsx
│   ├── types.ts
│   └── hooks/
│       └── usePanelState.ts
└── ObjectEditorLayout/
    ├── ObjectEditorLayout.tsx
    └── components/
        ├── HeaderControls/
        └── PanelContainer/
```

### Решение размещения UI для objectEditor

Проанализировав структуру `object-editor/ui`, предлагается:

**Вариант 1: Новая вкладка/панель**
- Добавить вкладку "Чат" рядом с существующими панелями управления
- Расположить справа от основного 3D viewport'а

**Вариант 2: Выдвижная панель**
- Collapse/expand панель снизу интерфейса
- Аналогично тому как работает `onCollapse` в текущем ChatInterface

**Вариант 3: Модальное окно**  
- Floating chat window, вызываемый по кнопке/хоткею
- Минимальное вмешательство в существующий UI

**Рекомендация: Вариант 2** - выдвижная панель снизу, так как:
- Не нарушает существующую компоновку
- Аналогична текущему поведению ChatInterface
- Обеспечивает достаточно места для работы

### Техническая оценка (обновленная)

**Зависимости для миграции:**
- Все импорты ChatInterface в sceneEditor нужно обновить
- LangChain сервисы - общие для обеих фич
- AI tools - потребуют адаптации под каждую фичу

**Риски:**
- Дублирование LangChain логики между фичами
- Потенциальные проблемы с hot reload при рефакторинге
- Необходимость синхронизации состояния чатов

**Предлагаемые решения:**
- Создать общий `useLangChainService` хук в shared
- Вынести tool registration в отдельные модули  
- Использовать единую конфигурацию подключений OpenAI

## Комментарии пользователя
Мысли по поводу размещения ChatPanel в ObjectEditor.
Сейчас ObjectEditor открывается в двух вариантах:
  - Страница редактирования объекта
  - Модельное окно редактирования объекта сцены
В обоих случаях сверху остается много пустого места: 
  - на странице редактирования объекта - панель header, где на этой странице только логотип
  - в модальном окне пустая панель сверху, только крестик закрытия модалки

Нужно: в обоих случаях в верхнюю панель добавить иконки toggle панелей ObjectEditor:
- Правая панель ObjectManagementPanel
- левая панель - PrimitiveControlPanel или MaterialControlPanel(сейчас показываются в зависимости от того, что выбрано в правой панели)
- в левой же панели окно чата

Итого: в верхней панели будет 3 иконки: чат(новый компонент), свойства(PrimitiveControlPanel или MaterialControlPanel), менеджер (ObjectManagementPanel)
- При активации "менеджер", будет открываться/скрываться ObjectManagementPanel
- При активации чата будет отображаться слева чат. если открыты "свойства", они будут автоматически скрываться.
- При выборе в менеджере примитива или материала, чат будет скрываться и отображаться свойства.
- Иконки будут отображать активность соответствующих панелей.
- Для страницы редактирования объекта - иконки в rightSection header
- Для модального окна - иконки в шапке окна рядом с иконкой закрытия окна

### Обновленное решение UI для ObjectEditor

**Принятое решение**: Размещение чата в левой панели с переключателями в шапке

**Техническая реализация:**
1. **Создание компонента ToggleButtons** для управления панелями:
   - Иконка чата (новый компонент)
   - Иконка свойств (PrimitiveControlPanel/MaterialControlPanel)
   - Иконка менеджера (ObjectManagementPanel)

2. **Логика переключения панелей:**
   - Чат и свойства - взаимоисключающие (левая панель)
   - Менеджер - независимый (правая панель)
   - Автоматическое скрытие чата при выборе примитива/материала
   - Визуальная индикация активных панелей

3. **Интеграция в двух режимах:**
   - **Страница редактирования**: кнопки в rightSection header
   - **Модальное окно**: кнопки в шапке рядом с крестиком закрытия

4. **Состояние панелей:**
   - Использовать общий стейт для управления видимостью
   - Синхронизация между режимами отображения
   - Сохранение предпочтений пользователя

### Обновленный план миграции (с учетом пользовательских требований)

**Фаза 1: Создание базовой инфраструктуры**
1. Создать `shared/entities/chat` с базовой функциональностью
2. Создать `shared/ui/PanelToggleButtons` для переключения панелей
3. Создать типы для состояния панелей (`PanelState`, `PanelType`)

**Фаза 2: Рефакторинг ObjectEditor layout**
1. Создать `ObjectEditorLayout` компонент для управления панелями
2. Интегрировать toggle buttons в header (страница) и modal header
3. Реализовать логику взаимоисключающего отображения левых панелей

**Фаза 3: Миграция SceneEditor ChatInterface**
1. Перенести специфичную логику в `features/scene/ui/ChatInterface`
2. Обновить импорты в sceneEditor
3. Тестирование обратной совместимости

**Фаза 4: Создание ObjectEditor ChatInterface**
1. Создать `features/object-editor/ui/ChatInterface/ObjectChatInterface`
2. Интегрировать в новый layout с toggle системой
3. Добавить специфичные для object-editor AI tools

**Фаза 5: Финализация и тестирование**
1. Удаление старого `widgets/ChatInterface.tsx`
2. Полное тестирование обеих фич
3. Проверка производительности и UX

## Этапы валидации
- **Быстрое прототипирование**: [не проводилось]
- **Проверка обратной совместимости**: [планируется]
- **Оценка производительности**: [планируется]
- **Тестирование граничных случаев**: [планируется]

## Консенсус
[Требуется участие дополнительных агентов]

## Постановка для исполнения
[Будет сформулирована после достижения консенсуса]
